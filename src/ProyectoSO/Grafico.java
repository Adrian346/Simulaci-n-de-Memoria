/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoSO;

import static java.lang.Thread.sleep;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Adrian Lopez
 */

public class Grafico extends javax.swing.JFrame {

    public ArrayList<Procesos> Procesos=new ArrayList();
    public ArrayList<Procesos> Memoria=new ArrayList();
    Grafico obj;
    public int id=0;
    public int espera=0;
    public int tiempoEj,tamañoMem;
    public int ajuste;
    public int cuanto;
    public int tamMaxProc;
    public int tamMaxCuanto;
    public int bandera=0;
    public int velocidad=50;
    String ajusteAux;
    
    boolean band;
    int tamaño;
    public int recorre;
    public long ProsAtendidos=0;
    public int ocupada=0;
    public float PorcentajeOc=0;
    public float PorcentajeTot=0;
    public int ciclos=0;
    public int desperdicio=0;
    public static int k=0;
    //cola que lleva el control del planificador
    Queue<Integer> qe=new LinkedList<>();
    //lista que guarda a los procesos con su id, contabiliza el tiempo y las veces que han entrado al micro
    ArrayList<atencionProcesos> tiempo = new ArrayList<>();
    //levara el promedio de atencion por proceso de cada uno (tiempo/veces que entro)
    ArrayList<Float> promTiempoProceso = new ArrayList<>();
    
    
    /**
     * Creates new form Grafico
     */
    public Grafico() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        Tiempo = new javax.swing.JTextField();
        Mem = new javax.swing.JTextField();
        MemP = new javax.swing.JTextField();
        QuantumsP = new javax.swing.JTextField();
        QuantumsS = new javax.swing.JTextField();
        jComboBox1 = new javax.swing.JComboBox<>();
        jSlider1 = new javax.swing.JSlider();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        Comenzar = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        Tabla = new javax.swing.JTable();
        jScrollPane2 = new javax.swing.JScrollPane();
        Mostrar = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Tiempo de Ejecución");

        jLabel2.setText(" Memoria");

        jLabel3.setText("Memoria por Proceso");

        jLabel4.setText("Quantums por Proceso");

        jLabel5.setText("Quantums del Sistema");

        Tiempo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TiempoActionPerformed(evt);
            }
        });

        MemP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MemPActionPerformed(evt);
            }
        });

        QuantumsP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                QuantumsPActionPerformed(evt);
            }
        });

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Algoritmo", "Primer Ajuste", "Mejor Ajuste", "Peor Ajuste" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jSlider1.setMajorTickSpacing(10);
        jSlider1.setPaintLabels(true);
        jSlider1.setPaintTicks(true);
        jSlider1.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jSlider1.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSlider1StateChanged(evt);
            }
        });

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(102, 102, 255));
        jLabel7.setText("Algoritmo");

        Comenzar.setFont(new java.awt.Font("Verdana", 1, 24)); // NOI18N
        Comenzar.setText("Comenzar");
        Comenzar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ComenzarActionPerformed(evt);
            }
        });

        Tabla.setBackground(new java.awt.Color(204, 204, 255));
        Tabla.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Id", "Memoria", "Quantums"
            }
        ));
        Tabla.setToolTipText("");
        jScrollPane1.setViewportView(Tabla);

        Mostrar.setEditable(false);
        Mostrar.setColumns(20);
        Mostrar.setRows(5);
        jScrollPane2.setViewportView(Mostrar);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(Tiempo, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(38, 38, 38)
                                .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(Mem, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel4))
                                .addGap(47, 47, Short.MAX_VALUE)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(QuantumsP, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(MemP, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(QuantumsS, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                    .addComponent(jSlider1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(102, 102, 102)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(Comenzar, javax.swing.GroupLayout.PREFERRED_SIZE, 184, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel5)))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 209, Short.MAX_VALUE))))
                .addContainerGap(271, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(Tiempo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(27, 27, 27)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel2)
                            .addComponent(Mem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel3)
                            .addComponent(MemP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel4)
                            .addComponent(QuantumsP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5)
                            .addComponent(QuantumsS, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSlider1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Comenzar))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(42, 42, 42)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 233, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void MemPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MemPActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_MemPActionPerformed

    private void TiempoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TiempoActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_TiempoActionPerformed

    private void jSlider1StateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSlider1StateChanged
        jLabel6.setText("Velocidad: "+jSlider1.getValue());
        velocidad = jSlider1.getValue();
    }//GEN-LAST:event_jSlider1StateChanged

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        ajusteAux=jComboBox1.getSelectedItem().toString();
    }//GEN-LAST:event_jComboBox1ActionPerformed

    Thread h = new Thread();
    private void ComenzarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ComenzarActionPerformed
         final Grafico obj = new Grafico();
        ajusteAux=jComboBox1.getSelectedItem().toString();
        obj.tiempoEj=Integer.parseInt(Tiempo.getText());
        obj.tamañoMem=Integer.parseInt(Mem.getText());
        obj.tamMaxProc=Integer.parseInt(MemP.getText());
        obj.tamMaxCuanto=Integer.parseInt(QuantumsP.getText());
        obj.cuanto=Integer.parseInt(QuantumsS.getText());
        switch(ajusteAux){
            case "Primer Ajuste": obj.ajuste=1; jLabel7.setText("Primer Ajuste"); break;
            case "Mejor Ajuste": obj.ajuste=2; jLabel7.setText("Mejor Ajuste"); break;
            case "Peor Ajuste": obj.ajuste=3; jLabel7.setText("Peor Ajuste"); break;
        }
        this.obj=obj;
        band=true;
        this.obj.Memoria.add(new Procesos(obj.tamañoMem,1)); //agrega  al array de memoria objeto anonimo
        tiempo.add(new atencionProcesos(0,0,0));
        h = new Thread(){
        @Override
        public void run() {
            try {
            principal();
            } catch (Exception e) {}
        };
    };
                h.start();
    }//GEN-LAST:event_ComenzarActionPerformed

    private void QuantumsPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_QuantumsPActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_QuantumsPActionPerformed
    public void principal(){
                final int tiempoEjInicial= obj.tiempoEj;
                int prosEnMemoria=0,i;
                float tiempoTotalProcesos=0;
                    while(obj.tiempoEj>0){ //mientras haya tiempo
                        try{
                        sleep(velocidad*10);
                        }catch(Exception e){}
                    if(obj.bandera==0){
                        //sleep(Grafico.velocidad);
                        //Ejecute y debe entrar un proceso             
                        ajustes();
                    }
                    //Se va al menu de uno de los 3 ajustes o crea un nuevo pros
                    else if(obj.bandera==1){  
                        PorcentajeOc=(ocupada/(float)obj.tamañoMem)*100;
                        PorcentajeTot+=PorcentajeOc;
                        ciclos++;
                control();
                        //comprobar estadisticas por ciclo
                        //ciclo para comprobar que los tiempos de cada proceso estan correctos
                    }
                    }
                //Sumo el total de tiempo de cada uno de los procesos atendidos
                for(i=0;i<promTiempoProceso.size();i++){
                    tiempoTotalProcesos+= promTiempoProceso.get(i);
                }        
                System.out.println("\nTiempo medio de atención a procesos: "+tiempoTotalProcesos/(float)ProsAtendidos);
                System.out.println("Procesos atendidos: "+ ProsAtendidos);
                System.out.println("Promedio de porcentaje de memoria: "+ PorcentajeTot/(float)ciclos+"%");
                System.out.println("Tiempo desperdiciado total en el micro: "+desperdicio);
                System.out.println("En promedio, los procesos terminaron cada "+(float)tiempoEjInicial/(float)ProsAtendidos+" cuantos");
                for( i=0;i<obj.Memoria.size();i++){
                    if(obj.Memoria.get(i).idPros!=0)
                        prosEnMemoria++; 
                }
                System.out.println("El numero de procesos que permanecieron en la memoria fueron: "+prosEnMemoria);
    }
    public void control(){
        int  banderita=0;
        recorre=0;
        
            do{
                if(obj.Memoria.get(recorre).idPros==qe.peek()){
                 banderita=1;                      
                 }else{
                    recorre++;
                } 
           }while(banderita!=1);
            ejecuta();
        
    }
    public void ejecuta(){
        int var=0,j;
        int cola;
        
        if(obj.tiempoEj>0){ //si hay tiempo de Ej   
            obj.bandera=0; //cuando ejecuta bajo la bandera
            obj.tiempoEj-=1; //elimina tiempo
            
            for(j=0;j<tiempo.size();j++){
                     //aumento tiempo a todos los procesos expeto al que esta en ejecucion
                    if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)                       
                        tiempo.get(j).tiempo++; 
                     }
           System.out.println("Cargando al micro el Proceso "+obj.Memoria.get(recorre).idPros +"     ");//"carga a la memoria"  
           Mostrar.setText("Cargando al micro el \nProceso "+obj.Memoria.get(recorre).idPros +"     ");
           tiempo.get(recorre).iveces+=1;
        }
         if(obj.tiempoEj>0){// si sigue habiendo tiempoEj
            obj.tiempoEj-=obj.cuanto;// quita tiempo de ejecucion el cuanto del sistema
            
            for(j=0;j<tiempo.size();j++){
                     //aumento tiempo a todos los procesos expeto al que esta en ejecucion
                    if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)
                        //aumeto el tiempo que se quedo en el micro
                        tiempo.get(j).tiempo+=obj.cuanto; 
                 }
            obj.Memoria.get(recorre).cuantoPros -= obj.cuanto; //Se disminuye el cuanto del proceso recorrido
            //aumetar el desperdicio del cuanto    
            if(obj.Memoria.get(recorre).cuantoPros<0){
                desperdicio+=((-1)*obj.Memoria.get(recorre).cuantoPros);
                obj.Memoria.get(recorre).cuantoPros=0;
                
            }
            System.out.println("Ejecutando el Proceso "+obj.Memoria.get(recorre).idPros+"     ");   
            Mostrar.setText("Ejecutando el Proceso \n"+obj.Memoria.get(recorre).idPros+"     ");
        }
         if(obj.tiempoEj>0){// si sigue habiendo tiempoEj
            obj.tiempoEj-=1; 
            
            for(j=0;j<tiempo.size();j++){
                     //aumento tiempo a todos los procesos expeto al que esta en ejecucion
                    if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)
                        tiempo.get(j).tiempo++; 
                 }
            
            System.out.println("Descargando del micro el Proceso "+obj.Memoria.get(recorre).idPros+"     ");  
            Mostrar.setText("Descargando del micro el \nProceso "+obj.Memoria.get(recorre).idPros+"     ");
            System.out.println(mostrar()); // manda mostrar como esta la mem
            llenarTabla();
            try{
            Thread.sleep(velocidad*10);
            }catch(Exception e){}
         }
        
            
           //si los cuantos del proceso en indice es menor que 1 (ya termino su ejecucion) y aun hay tiempo
            if(obj.Memoria.get(recorre).cuantoPros ==0 && obj.tiempoEj > 0){
                obj.tiempoEj-=1; //disminye tiempo
                
                for(j=0;j<tiempo.size();j++){
                     //aumento a todos los procesos excepto al que esta en ejecucion
                    if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)
                        tiempo.get(j).tiempo++; 
                 }
                
                ocupada-=obj.Memoria.get(recorre).tamañoPros;//resto el espacio de mem total ocupado lo que se libero
                
               
                System.out.println("Proceso "+obj.Memoria.get(recorre).idPros+" termino su ejecucion"+"     ");
                Mostrar.setText("Proceso "+obj.Memoria.get(recorre).idPros+" \ntermino su ejecucion"+"     ");
                //agrego el promedio de tiempo de atencion del proceso a la lista
                promTiempoProceso.add(((float)tiempo.get(recorre).tiempo)/((float)tiempo.get(recorre).iveces));
                qe.remove(); //elimino al proceso del plificador de cola
                ProsAtendidos++; //aumento mi var de procesos promTiempoProceso
                 obj.Memoria.get(recorre).idPros=0; //Pone el i del proceso como libre (cero)
                 tiempo.get(recorre).id=0;
                System.out.println(mostrar()); //imprime el estado actual de la mem
                if(obj.tiempoEj>0){
                    System.out.println("Checando si se puede condensar");
                    Mostrar.setText("Checando si se puede condensar");
                    obj.tiempoEj-=1; //elimino tiempo
                    
                    for(j=0;j<tiempo.size();j++){
                            //aumento tiempo a todos los procesos expeto al que esta en ejecucion
                            if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)                                
                                tiempo.get(j).tiempo++; 
                        }
                    
                    
                    
                    if(recorre+1<obj.Memoria.size()){ //si el indice es menor al tamaño de la lista de mem
                       // si en la posicion siguiente de la lista esta libre(no hay otro proceso)
                        if(obj.Memoria.get(recorre+1).cuantoPros==0){
                            //el tamaño del espacio en memoria va a ser igual a la suma de los dos espacios (compacta)
                            obj.Memoria.get(recorre).tamañoPros+=obj.Memoria.get(recorre+1).tamañoPros;
                            llenarTabla();
                            try{
                                Thread.sleep(velocidad*10);
                            }catch(Exception e){}
                            obj.Memoria.remove(recorre+1); //elimina el indice sobrante
                            var=1; //condense
                            tiempo.remove(recorre+1);
                         }
                       }
                    if(recorre>0){
                        //ahora checo si el espacio ANGTERIOR al que liberé se puede juntar
                        
                        if(obj.Memoria.get(recorre-1).cuantoPros==0){
                            //sumo los dos espacios de memoria vacia
                            obj.Memoria.get(recorre).tamañoPros=obj.Memoria.get(recorre-1).tamañoPros+obj.Memoria.get(recorre).tamañoPros;
                            llenarTabla();
                            try{
                                Thread.sleep(velocidad*10);
                            }catch(Exception e){}
                            
                            for(j=0;j<tiempo.size();j++){
                            //aumento tiempo a todos los procesos expeto al que esta en ejecucion
                            if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)                                
                                tiempo.get(j).tiempo++; 
                        }
                            
                            obj.Memoria.remove(recorre-1); //elimino indice sobrante
                            tiempo.remove(recorre-1);
                            var=1; //si puede condensar
                        }
                    }
                    if(var ==1){ //si logre condensar
                        obj.tiempoEj-=1; //elimino tiempo
                        
                        
                        
                        
                        System.out.println("Condensando...");
                        Mostrar.setText("Condensando...");
                        System.out.println(mostrar());//muetro estado actual mem
                        llenarTabla();
                        try{
                        Thread.sleep(velocidad*10);
                        }catch(Exception e){}
                    } 
                        
                        
                    }
                }else{
                 obj.tiempoEj-=1; //disminye tiempo
                System.out.println("Proceso "+obj.Memoria.get(recorre).idPros+" se regresa a la lista de listos");
                Mostrar.setText("Proceso "+obj.Memoria.get(recorre).idPros+"\n se regresa a la lista de listos");
                cola= qe.poll();
                qe.add(cola);
                           
                for(j=0;j<tiempo.size();j++){
                     //aumento tiempo a todos los procesos expeto al que estaba en ejecucion
                    if(tiempo.get(j).id!=obj.Memoria.get(recorre).idPros)
                        tiempo.get(j).tiempo++; 
                 }
            }
    }
    public void ajustes(){
      
        if(obj.Procesos.size()==1){ //
            obj.bandera=1; //subo la bandera, ya hice seleccion de ajuste y ahora ocupo ejecutar
            switch(obj.ajuste){
                case 1:
                    primerAjuste();
                break;
                case 2:
                    peorAjuste();
                break;
                case 3:
                    mejorAjuste();
                break;
            }
        }
        else{ //Proceso que voy a estar checando donde entrar
            obj.Procesos.add(new Procesos(obj.id,obj.tamMaxCuanto,obj.tamMaxProc));
        }
        
    }
    public void primerAjuste(){
        int i=0;
        System.out.println("\n"+obj.tiempoEj);
        System.out.println("Checando si se puede insertar a la memoria ["+(obj.Procesos.get(0).idPros)+","+obj.Procesos.get(0).tamañoPros+","+obj.Procesos.get(0).cuantoPros+"]");    
        Mostrar.setText(obj.tiempoEj+"\nChecando si se puede insertar a \nla memoria ["+(obj.Procesos.get(0).idPros)+","+obj.Procesos.get(0).tamañoPros+","+obj.Procesos.get(0).cuantoPros+"]");
        obj.tiempoEj-=1; //resto tiempo 
        System.out.println(mostrar());
        llenarTabla();
        try{
            Thread.sleep(velocidad*10);
        }catch(Exception e){}
        
        //aumento tiempo a todos los procesos porque ninguno esta en el micro            
             for(int j=0;j<tiempo.size();j++){
                 tiempo.get(j).tiempo++;
             }
             
        while(i<obj.Memoria.size()){ //mientras el i no sea mayor al tamaño de la lista existente de mem
          // if(obj.Procesos.size()==1){ 
                 //si el proceso cabe en el espacio de memoria i, y esta dispoble el espacio (iMax==0)
                 //obj.Procesos.get(0) es el proceso que esta por entrar
             if(obj.Procesos.get(0).tamañoPros <= obj.Memoria.get(i).tamañoPros && obj.Memoria.get(i).idPros==0){
               
                //si se deja espacio restante despues de hacer la resta de mem disponible y la del proceso que entro
                 if(obj.Memoria.get(i).tamañoPros-obj.Procesos.get(0).tamañoPros!=0){
                     //se agrega un nuevo objeto de procesos a la lista de espacio de memoria en la pos sig
                    obj.Memoria.add(i+1, new Procesos(obj.Memoria.get(i).tamañoPros - obj.Procesos.get(0).tamañoPros,1));
                    tiempo.add(i+1,new atencionProcesos(0,0,0));
                }
                 
                obj.Memoria.set(i,obj.Procesos.get(0)); //se mete a la memoria en la posicion i el proceso
                tiempo.set(i,new atencionProcesos(obj.Procesos.get(0).idPros,0,0));
                System.out.println("Entra Proceso ["+(obj.id+1)+","+obj.Procesos.get(0).tamañoPros+","+obj.Memoria.get(i).cuantoPros+"]       "+"\n"+mostrar());
                Mostrar.setText("Entra Proceso ["+(obj.id+1)+","+obj.Procesos.get(0).tamañoPros+","+obj.Memoria.get(i).cuantoPros+"] ");
                i=obj.Memoria.size()+1; //rompo el ciclo de busqueda y me sirve de bandera para el sig if
                qe.add(obj.Procesos.get(0).idPros);
                ocupada+=obj.Procesos.get(0).tamañoPros;//agrego el espacio que se ocupara de mem a ocupada
                //agrego el nuevo proceso a mi lista de contabilizar el tiempo
                 
                
            }else{ //si no cabe buscamos en la pos siguiente de la mem
                
                 i++;
                 
             }
       // }
         
        if(i==obj.Memoria.size()+1 ){ //si logre insertar en la memoria
            obj.id++;//aumento mi iMax
            obj.Procesos.remove(0);//como ya agregue a la memoria el proceso por entrar, lo elimino
        }   
        }
    }
    public void peorAjuste(){
        int iMax=0;//guarda la posicion del espacio mas grande
        int i=0; //pivote
        int tamMax=0;//guarda el tamaño max disponible
        int bande=0; //sirve para saber si si se metio a la memoria un proceso
        if(obj.tiempoEj > 0){
            System.out.println("\n"+obj.tiempoEj);
            System.out.println("Checando si se puede insertar a la memoria ["+(obj.Procesos.get(0).idPros)+","+obj.Procesos.get(0).tamañoPros+","+obj.Procesos.get(0).cuantoPros+"]");   
            Mostrar.setText(obj.tiempoEj+"\nChecando si se puede insertar a \nla memoria ["+(obj.Procesos.get(0).idPros)+","+obj.Procesos.get(0).tamañoPros+","+obj.Procesos.get(0).cuantoPros+"]");   
            obj.tiempoEj-=1; //resto tiempo   
            System.out.println(mostrar());
            llenarTabla();
            try{
            Thread.sleep(velocidad*10);
            }catch(Exception e){}
            
            //aumento tiempo a todos los procesos porque ninguno esta en el micro            
             for(int j=0;j<tiempo.size();j++){
                 tiempo.get(j).tiempo++;
             }
             
        while(i < obj.Memoria.size()){ //buscamos si hay espacio en la memoria para que entre el nuevo proceso
            //si el iMin del proceso esta en 0 (vacio) en la posicion donde estoy y
            //el tamaño mayor hasta ahora es menor al tamaño del proceso (cabe)
            if(obj.Memoria.get(i).idPros == 0 && tamMax < obj.Memoria.get(i).tamañoPros){
                tamMax=obj.Memoria.get(i).tamañoPros; //guardo el valor del tamMax de mem del proceso donde estoy
                iMax=i; //guardo la pos del supuesto tamaño max
            }
            i++; //muevo de pos a seguir buscando
        }
        //si el tamaño del proceso por entrar es menor al tamaño de la memoria y esta dispoble el espacio
        if(obj.Procesos.get(0).tamañoPros <= obj.Memoria.get(iMax).tamañoPros && obj.Memoria.get(iMax).idPros==0){
           //si se deja espacio restante despues de hacer la resta de la mem dsiponible y la del proceso que entro
           if(obj.Memoria.get(iMax).tamañoPros - obj.Procesos.get(0).tamañoPros!=0){
               //agrego un nuevo objeto a la lista de mem en la sig pos
               obj.Memoria.add(iMax+1, new Procesos(obj.Memoria.get(iMax).tamañoPros-obj.Procesos.get(0).tamañoPros,1));
               tiempo.add(iMax+1,new atencionProcesos(0,0,0));
              }
           //se agrega la poscion y el  proceso a la mem
           obj.Memoria.set(iMax,obj.Procesos.get(0));
           tiempo.set(iMax,new atencionProcesos(obj.Procesos.get(0).idPros,0,0));
           System.out.println("Entra Proceso ["+(obj.id+1)+","+obj.Procesos.get(0).tamañoPros+","+ obj.Memoria.get(iMax).cuantoPros +"]       "+"\n"+mostrar());
           Mostrar.setText("Entra Proceso ["+(obj.id+1)+","+obj.Procesos.get(0).tamañoPros+","+obj.Memoria.get(i).cuantoPros+"] ");
           bande=1;
           qe.add(obj.Procesos.get(0).idPros);
           ocupada+=obj.Procesos.get(0).tamañoPros;
         }
        //me recorro sobre la mem y el id
        if(bande==1){
            obj.id++; //aumento id
            obj.Procesos.remove(0); //elimino proceso que ya se metio a la memoria
        }    
        }
    }
    public void mejorAjuste(){
        int iMin=0;
        int i=0;
        int tam=obj.tamañoMem+1;
        int bande=0;//sirve para saber si si se metio a la memoria un proceso
        if(obj.tiempoEj>0){
           System.out.println("\n"+obj.tiempoEj);
           System.out.println("Checando si se puede insertar a la memoria ["+(obj.Procesos.get(0).idPros)+","+obj.Procesos.get(0).tamañoPros+","+obj.Procesos.get(0).cuantoPros+"]");    
           Mostrar.setText(obj.tiempoEj+"\nChecando si se puede insertar a \nla memoria ["+(obj.Procesos.get(0).idPros)+","+obj.Procesos.get(0).tamañoPros+","+obj.Procesos.get(0).cuantoPros+"]");
           System.out.println(mostrar());
           llenarTabla();
           try{
            Thread.sleep(velocidad*10);
            }catch(Exception e){}
             obj.tiempoEj-=1; //resto tiempo 
            
             //aumento tiempo a todos los procesos porque ninguno esta en el micro            
             for(int j=0;j<tiempo.size();j++){
                 tiempo.get(j).tiempo++;
             }

        while(i<obj.Memoria.size()){    
            //si el espacio esta libre, si el tamaño de la posible memoria ocupada es mayor a una posbible menor y cabe el proceso
            if((obj.Memoria.get(i).idPros==0) && (tam > (obj.Memoria.get(i).tamañoPros - obj.Procesos.get(0).tamañoPros)) && ((obj.Memoria.get(i).tamañoPros-obj.Procesos.get(0).tamañoPros) >= 0))
            {
                tam=obj.Memoria.get(i).tamañoPros - obj.Procesos.get(0).tamañoPros;//guardo el espacio donde cabe mejor
                iMin=i; //y guardo la posicion en memoria donde se encuentra
            }
                i++;//sigo buscando en la lista
         }
            //si el proceso por entrar cabe en la min posicion de la memoria (si si entro xq pudo haberse quedado con el tamaño de toda la memoria)
            if(obj.Procesos.get(0).tamañoPros <= obj.Memoria.get(iMin).tamañoPros && obj.Memoria.get(iMin).idPros==0){
                //si sobra espacio, creo un nuevo espacion en la memoria
                if(obj.Memoria.get(iMin).tamañoPros-obj.Procesos.get(0).tamañoPros!=0){
                    obj.Memoria.add(iMin+1, new Procesos(obj.Memoria.get(iMin).tamañoPros-obj.Procesos.get(0).tamañoPros,1));
                    tiempo.add(iMin+1,new atencionProcesos(0,0,0));
                }
                obj.Memoria.set(iMin,obj.Procesos.get(0)); 
                 //meto el proceso a mi lista para contaabilizar el tiempo
                tiempo.set(iMin,new atencionProcesos(obj.Procesos.get(0).idPros,0,0));
                System.out.println("Entra Proceso ["+(obj.id+1)+","+obj.Procesos.get(0).tamañoPros+","+obj.Memoria.get(iMin).cuantoPros+"]"+"\n"+mostrar());
                Mostrar.setText("Entra Proceso ["+(obj.id+1)+","+obj.Procesos.get(0).tamañoPros+","+obj.Memoria.get(i).cuantoPros+"] ");
                qe.add(obj.Procesos.get(0).idPros);//agrego el id del proceso que entre a la cola
                //para contabilizar el tiempo         
                 bande=1;//si entro
                 //sumo el espacio de memoria ocuapada en mi variable ocupada
                 ocupada+=obj.Procesos.get(0).tamañoPros;
            }
        
        if(bande==1){//si logro entrar el procesi
            obj.id++;
            obj.Procesos.remove(0);
        }    
        }
    }
    public String mostrar(){
        int i=0;
        String muestra = ""; //cadena final
        while(i<obj.Memoria.size()){ //mientras no recorra toda la lista

            muestra=muestra+"[ "+obj.Memoria.get(i).idPros+","+obj.Memoria.get(i).tamañoPros+","+obj.Memoria.get(i).cuantoPros+" ]";
            i++;
        }
        muestra=muestra+"     ";
        return muestra;
    }
    public void llenarTabla(){
        int i=0;
        String []titulos = {"Id","Memoria","Quantums"};
        String data[][]=new String[obj.Memoria.size()][3];
        while(i<obj.Memoria.size()){
            data[i][0]=Integer.toString(obj.Memoria.get(i).idPros);
            data[i][1]=Integer.toString(obj.Memoria.get(i).tamañoPros);
            data[i][2]=Integer.toString(obj.Memoria.get(i).cuantoPros);
            i++;
        }
        DefaultTableModel dataModel=new DefaultTableModel(data, titulos);
        Tabla.setModel(dataModel);
    }
    
     /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Grafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Grafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Grafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Grafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Grafico().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Comenzar;
    private javax.swing.JTextField Mem;
    private javax.swing.JTextField MemP;
    public javax.swing.JTextArea Mostrar;
    private javax.swing.JTextField QuantumsP;
    private javax.swing.JTextField QuantumsS;
    private javax.swing.JTable Tabla;
    private javax.swing.JTextField Tiempo;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSlider jSlider1;
    // End of variables declaration//GEN-END:variables
}
